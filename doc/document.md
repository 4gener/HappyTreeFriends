## 1. 题材综述
上海是一座繁华的城市，在这座魔幻之都里，一切皆有可能。比如，就有这样一家欢乐餐厅，它只售卖汉堡和饮料，却隐含着设计模式的迷幻奥秘。

当顾客来到餐厅时，他可以下单一份汉堡或饮料，如果是大胃王的话，点上几个汉堡或是几个饮料也没什么不可能。当顾客付钱、厨师接到订单时，他会按照顾客的要求呈现美味，聪明地他也会无视订单中各种商品的下单顺序，用他的智慧完成烹饪的过程。如果需要制作一个汉堡，厨师会从壁橱中拿出汉堡坯，然后根据不同的汉堡种类做出不同的反应——烤一块牛肉饼做成牛肉汉堡，烤一片培根做成培根汉堡，或是两个都来，做成双拼豪华汉堡，享受双份美味。肉被厨师从冰箱中取出，放上烤架，烤熟后放入操作台上的汉堡坯中，别忘了加上生菜和西红柿，做成的汉堡就可以放到托盘里了。

啊呀？汉堡肉烤糊了？没关系，神奇的欢乐餐厅总有办法，哔哔哔叭叭哔嗙！肉就复原到生的状态了！

诶？没有牛肉饼/培根/汉堡坯/西红柿/生菜了？没关系，欢乐餐厅里的厨师说话好听又厉害，他可以去进货，也可以暂时创建一个缺少材料的“空汉堡”，原料到了再加进去。

当顾客想要的所有美味都进入托盘后，顾客就可以享用了。享用美味，就在神奇的欢乐餐厅！


## 2. Design Pattern 汇总表

| 编号 | Design pattern name           | 实现个（套）数 | sample programs个数 | 备注 |
| ---- | ----------------------------- | -------------- | ------------------- | ---- |
| 1    | 单例模式 Singleton            |                |                     |      |
| 2    | 抽象工厂模式 Abstract Factory |                |                     |      |
| 3    | 工厂模式 Factory              |                |                     |      |
| 4    | 模板模式 Template             |                |                     |      |
| 5    | 观察者模式 Observer           |                |                     |      |
| 6    | 迭代器模式 Iterator           |                |                     |      |
| 7    | 状态模式 State                |                |                     |      |
| 8    | 命令模式 Command              |                |                     |      |
| 9    | 装饰器模式 Decorator          |                |                     |      |
| 10   | 策略模式 Strategy             |                |                     |      |
| 11   | 建造者模式 Builder            |                |                     |      |
| 12   | 桥接模式 Bridge               |                |                     |      |
| 13   | 中介者模式 Mediator           |                |                     |      |
| 14   | 外观模式 Facade               |                |                     |      |
| 15   | 享元模式 Flyweight            |                |                     |      |
| 16   | 原型模式 Prototype            |                |                     |      |
| 17   | 备忘录模式 Memento            |                |                     |      |
| 18   | 代理模式 Proxy                |                |                     |      |
| 19   | 空对象模式 Null Object        |                |                     |      |
| 20   | 组合模式 Composite            |                |                     |      |
| 21   | 访问者模式 Visitor            |                |                     |      |



## 3. Design Pattern 详述

### 3.1 单例模式 Singleton

#### 模式简介

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

#### 应用场景

在欢乐厨房中，有且仅有一个厨师，因此我们采用了单例模式来创建实例，并向其它对象提供这一实例。厨房中的容器（包括冰箱与壁橱）也符合这一模式。

- **Chef 厨师**

   为了保证仅有一个厨师，Chef类具有私有构造函数和本身的一个静态实例，并提供了getInstance()方法，供外界进行访问。

  ```java
  public final class Chef {
      private Chef() {
          if (instance == null) {
              instance = this;
          } else {
              throw new IllegalStateException("Already initialized.");
          }
      }
  
      private static Chef instance;
  
      public static synchronized Chef getInstance() {
          if (instance == null) {
              instance = new Chef();
          }
  
          return instance;
      }
  }
  ```

- **Container 容器 **

  Fridge类与Cabinet类扩展自Container类，也采用了Singleton模式，同样具有自身的私有构造函数与静态实例，提供了 getInstance() 方法。

  ```java
  代码
  ```



### 3.2 抽象工厂模式 Abstract Factory

#### 模式简介

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

#### 应用场景

汉堡工厂和饮料工厂都由商品工厂创建。

- **API **

  创建了抽象工厂类MerchFactory，工厂类BurgerFactory和BeverageFactory都是扩展自MerchFactory。然后创建了一个工厂创造器类MerchFactoryMaker，通过传递type信息来获取工厂类型。



### 3.3 工厂模式 Factory

#### 模式简介

工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

#### 应用场景

- **汉堡工厂/饮品工厂**

  创建了两个工厂类BurgerFactory/BeverageFactory，生成基于MerchType信息的实体类的对象

- **材料工厂**

  创建了一个工厂类IngredientFactory，生成基于IngredientType信息的实体类的对象。



### 3.4 模板模式 Template

#### 模式简介

在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

#### 应用场景

在制作菜品的过程中，具体的制作过程将根据菜品类型来确定，因此我们采用了模板模式来将制作步骤延迟到子类中。



### 3.5 观察者模式 Observer

#### 模式简介

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

#### 应用场景

在欢乐厨房中，原料的可食用状态会发生变化。当状态由新鲜变为腐烂时，其它对象都将得到通知。



### 3.6 迭代器模式 Iterator

#### 模式简介

迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。迭代器模式属于行为型模式。

#### 应用场景

我们使用了迭代器模式来提供方法遍历容器中的食材。此外，订单总价实际上为订单内部所有汉堡或套餐价格相加的总价，也采用了迭代器模式。



- **totalPrice()**

  遍历所有商品，返回商品的总价格。

  ```java
   public double totalPrice() {
          double price = 0;
          for (Merch merch : merches) {
              price += merch.getPrice();
          }
          return price;
      }
  ```



### 3.7 状态模式 State

#### 模式简介

在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。

#### 应用场景

食材的状态会影响它的行为，决定它是否可以被加入菜品。



### 3.8 命令模式 Command

#### 模式简介

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

#### 应用场景

厨师可以对食材和菜品进行操作，包括处理食材、制作菜品等等。



### 3.9 装饰器模式 Decorator

#### 模式简介

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

#### 应用场景

这种模式创建了一个装饰类TrayDecorator，用来实现接口 OrderInterface，

```java
  public class TrayDecorator implements OrderInterface {
    private Order order;

    public TrayDecorator(Order order) {
        this.order = order;
    }

    @Override
    public double totalPrice() {
        return order.totalPrice();
    }

    @Override
    public boolean hasTray() {
        return true;
    }
}
```



### 3.10 策略模式 Strategy

#### 模式简介

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

#### 应用场景

处理原材料的时候，不同材料需要使用不同的厨具进行处理。



### 3.11 建造者模式 Builder

#### 模式简介

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

#### 应用场景

- API

在创建订单的过程中，汉堡、饮料或套餐的选择顺序对订单的最终产出没有影响

创建了 OrderBuilder 类，其中包含带有 Merch 的 ArrayList 以及根据 MerchType 创建不同类型的Order对象。





### 3.12 桥接模式 Bridge
#### 模式简介
桥接模式（Bridge）是软件设计模式中较为复杂的模式之一，用于把抽象化和现实化解耦，使二者可以独立变化，这种类型的设计模式属于结构型模式，它通过提供抽象化和现实化之间的桥接结构来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。
#### 应用场景
当原料盛放在容器中时，容器在检测原料的可食用状态变化时实际上使用的是原料的内部方法；此外在订单部分，我们在计算订单总价的时候也使用了订单内部食物内部的抽象方法来获取食物的单价。

### 3.13 中介者模式 Mediator
#### 模式简介
中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性，这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护，中介者模式属于行为模式。中介者模式大多用在系统中对象之间依赖关系结构混乱或者想利用中间类来封装多个类中的行为的情况下。
#### 应用场景
当食物放进托盘中时，我们会使用一个中介者来访问订单，修改其状态为代待取餐。

### 3.14 外观模式 Facade
#### 模式简介
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。外观模式多用于为复杂模块提供外部访问接口，提高子系统的相对独立性。
#### 应用场景
汉堡的制作是一个极为复杂的过程，我们这里想对顾客隐藏后厨的制作细节，因此我们在这里使用“制作”这个接口来隐藏具体实现。

### 3.15 享元模式 Flyweight
#### 模式简介
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。享元模式大多用在系统中有大量相似的对象或者需要缓冲池的场景。
#### 应用场景
欢乐厨房里的原料会被厨具、容器和汉堡等多处共享，因此我们在这里使用享元模式来实现共享。

### 3.16 原型模式 Prototype
#### 模式简介
原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。该模式实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。
#### 应用场景
当欢乐厨房中的原料用尽时，厨师可以补充原料，因此为了简化模型复杂度我们这里使用原型模式对原有原料进行克隆。

### 3.17 备忘录模式 Memento
#### 模式介绍
备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于对象行为型模式。备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，捕获一个对象的状态捕捉，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。
#### 应用场景
食材处理过程可能出现意外，需要备忘录机制来进行处理。

### 3.18 代理模式 Proxy
#### 模式介绍
代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问，主要解决直接访问对象时的问题。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以用一个类代表另一个类的功能，在客户端和目标对象之间起到中介的作用。这种类型属于结构型模式。
#### 应用场景
下单时虽然目标是商品本身，但是实际实现是通过订单中添加商品。

### 3.19 空对象模式 Null Object
#### 模式简介
空对象模式（Null Object Pattern），用一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
#### 应用场景
制作汉堡时有可能遇到原料不足的状态，在创建汉堡实体时使用。

### 3.20 组合模式 Composite

#### 模式简介

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

#### 应用场景

订单中既可以包含食品、又可以包含食品组成的套餐

- **add(Merch merch)**

  订单的行为，向订单中增加商品，商品类型是merch，merch又有Coke和Burger两个子类。

  ```java
  public void add(Merch merch) {
          merches.add(merch);
      }
  ```



### 3.21 访问者模式 Visitor

#### 模式简介

在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

#### 应用场景

厨师在处理套餐的时候，实际上是对套餐内部了食品进行了处理